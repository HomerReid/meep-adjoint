""" Controls for the meep_adjoint GUI dashboard.

The first part of this module implements TunableDashboard,
a subclass of Ui_BaseDashboard (the bare-bones GUI widget
described by the 'dashboard_gui.ui' QTDesigner script) that
monitors an incoming data socket for commands to update
dashboard elements.

The second part of the module implements a server routine
that listens for connections to a TCP socket, then launches
the dashboard GUI and reads update commands from the client.
"""
import os
from os import environ as env
from os.path import dirname, abspath, pardir
import sys
import time
import select
import socket
import subprocess
import numpy as np
import re
from re import search as srch
from re import I

#######################################################################
# The standalone dashboard_server in its current incarnation has a
# meep dependency, but it would be fairly easy to remove this, which
# might be useful for running the dashboard on thin remote clients that
# have a standard python installation but not the full battery of
# MEEP packages and dependencies---smartphones, tablets, or just
# not-very-powerful laptops or workstations on which you want to
# monitor the progress of e.g. a large meep_adjoint optimization
# running on some supercomputer cluster somewhere.
#######################################################################
import meep as mp

######################################################################
# attempt to import packages with failures handled gracefully
######################################################################
try:
    # PyQt5
    from PyQt5 import QtCore, QtGui, QtWidgets
    from PyQt5.QtGui import QFont, QFontDatabase
    from PyQt5.QtCore import Qt, QSocketNotifier, QTimer
    from PyQt5.QtWidgets import (QApplication, QWidget, QLCDNumber,
                                 QLabel, QProgressBar)

    # dashboard_gui.py is a module autogenerated by QT Designer from
    # the design file dashboard_gui.ui. It implements a base class named
    # Ui_BaseDashboard, which we subclass below to define our TunableDashboard
    # class. We also need some general low-level utility routines. The
    # two syntax branches here reflect that this module may be imported
    # as part of the meep_adjoint package, or may be executed as a standalone
    # executable handling only the dashboard server.
    if __package__ == 'meep_adjoint':
        from . import init_log, log, warn, get_exception_info
        from . import get_adjoint_option as adj_opt
        from .dashboard_gui import Ui_BaseDashboard
        #import dashboard_theme
    else:
        PWD = dirname(abspath(__file__))
        sys.path.insert(0,dirname(PWD+os.path.pardir))
        from meep_adjoint.util import init_log, log, warn, get_exception_info
        from meep_adjoint import get_adjoint_option as adj_opt
        from meep_adjoint.dashboard_gui import Ui_BaseDashboard
        #import meep_adjoint.dashboard_theme

    # where does this line rightfully belong? or is it obviated by
    # the dashboard_theme import above?
    # QFontDatabase.addApplicationFont(':/ui/FantasqueSansMono-Regular.ttf')

except ImportError:
    info = sys.exc_info()
    sys.stderr.write('dashboard_server: exception in module import: {}\n'.format(info[0]))
    sys.stderr.write('Exception value: {}\n'.format(info[1]))


######################################################################
######################################################################
"""list of updatable display elements in the dashboard GUI"""
BUFSIZE = 4096
DASHBOARD_ELEMENTS = ['cpus', 'cpu_usage', 'ms_per_timestep',
                      'run', 'stage', 'progress',
                      'iteration', 'sub_iteration', 'alpha',
                      'start', 'current', 'best']

######################################################################
######################################################################
######################################################################
class TunableDashboard(Ui_BaseDashboard):
    """GUI dashboard with asynchronous updates via IPC or network.

    TunableDashboard inherits from Ui_BaseDashboard, the bare-bones
    GUI window described by the QT Designer file 'dashboard_gui.ui'.
    The base class defines the various display widgets, but doesn't provide
    any way to update their content after the window has launched.
    TunableDashboard improves on this by accepting the input parameter
    'sock', a caller-provided socket over which the caller may send
    commands to update dashboard display fields.
    """

    def setup(self, db_widget, sock, width=960, ffmly='Fantasque Sans Mono', fscale=1.0):
        """Initialization routine for GUI dashboard widget: Call
           the base-class initialization routine, then establish a
           callback to receive messages over the socket.
        """

        self.db_widget, self.sock = db_widget, sock
        self.setupUi(db_widget, width=width, ffmly=ffmly, fscale=fscale)

        """ tabulate distinct fonts in widget for subsequent use in rescaling, etc. """
        self.font_set = set()
        def find_fonts(w):
            if hasattr(w,'font'):
                self.font_set.add(w.font())
            for child in w.children():
                find_fonts(child)
        find_fonts(self.db_widget)
        log('Found {} fonts:'.format(len(self.font_set)))
        for font in self.font_set:
            log('  {}'.format(font.toString()))

        """ arrange for read_input to be called whenever data is available on the socket"""
        self.sock.setblocking(False)
        self.notifier = QSocketNotifier(sock.fileno(), QSocketNotifier.Read, db_widget)
        self.notifier.setEnabled(True)
        self.notifier.activated.connect(self.read_input)



    def read_input(self, fd):
        """ Callback invoked when there is input to read from the socket."""
        try:
            input = str(self.sock.recv(BUFSIZE), 'utf-8')
            if len(input)==0:
                condition = 'received EOF on socket'
            elif self.process_input(input) == False:
                condition = "received 'terminate' command"
            else:
                return
        except:
            condition = get_exception_info(msg='socket error', warning=True)

        log('{}; closing dashboard'.format(condition))
        self.sock.close()
        self.notifier.setEnabled(False)
        self.db_widget.close()


    def process_input(self, input):
        """ Process a batch of input received over the socket.

        Args:
            input (str): input received over the socket

        Returns:
            False: a 'terminate' command was received; the socket
                   and window should be shut down.
            True: No 'terminate' commant received; carry on as before.
        """
        for (ln, n) in [ (l,l.find(' ')) for l in input.split('\n') if l ]:
            key, val = (ln.lower(), '') if n<0 else (ln[:n].lower(), ln[n+1:])
            if key == 'terminate':
                return False
            elif key=='title':
                self.db_widget.setWindowTitle(val)
            elif key=='width':
                self.rescale( width_fraction = float(val) )
            elif key=='font_scale':
                for f in self.font_set:
                    f.setPointSize( int( float(val) * f.pointSize() ) )
            elif key == 'clear':
                for key in DASHBOARD_ELEMENTS:
                    self.update_item(key, '', redraw=False)
            elif key in DASHBOARD_ELEMENTS:
                self.update_item(key, val, redraw=False)
            else:
                log('ignoring unrecognized dashboard update: ' + ln)
        self.db_widget.update()
        return True


    def update_item(self, item, value, redraw=True):
        """ Set GUI dashboard element 'item' to value 'value.'
        """
        msg, w = None, self.get_widget_by_name(item)
        if isinstance(w, QLCDNumber):
            w.display(value)
        elif isinstance(w, QLabel):
            w.setText(value)
        elif isinstance(w, QProgressBar):
            tok = value.split()
            if len(tok) == 1 and tok[0].isdigit():
                w.setProperty('value', int(tok[0]) )
            elif len(tok) == 3 and tok[0] == 'range' and tok[1].isdigit() and tok[2].isdigit():
                w.setRange(int(tok[1]), int(tok[2]))
                w.setProperty('value', int(tok[1]))
            elif len(tok)>1:
                msg = 'failed to process progress-bar update: {} {}'.format(item, value)
        else:
            msg = 'failed to process update for unknown dashboard element {}={}'.format(item, value)

        if msg:
            log('warning: {}'.format(msg))
        elif redraw:
            self.db_widget.update()


    def get_widget_by_name(self, name):
        if name.lower() == 'progress':
            return self.progress
        for w in self.db_widget.children():
            if w.objectName().strip(' :').lower() == name.lower():
                return w
        return None


    # Auto-resizing of GUI dashboard window; Currently disabled.
    #
    # def rescale(self, scale_factor = None, rel_width = 0.5 )
    #     if scale_factor is None:
    #         old_width, new_width = self.db_widget.width(), rel_width * SX
    #         scale_factor = (1.0*new_width) / (1.0*old_width)
    #     self.scale_widget(self.db_widget, scale_factor, [])
    #     self.db_widget.update()
    #
    #
    # def scale_widget(self, w, sf, rescaled_fonts):
    #     if hasattr(w,'children'):
    #         for child in w.children():
    #             self.scale_widget(child, sf)
    #     if hasattr(w,'size'):
    #         w.resize( sf * w.size() )
    #         if w!=self.db_widget:
    #             w.move( int(sf*w.x()), int(sf*(w.y())) )
    #     if hasattr(w,'font') and w.font() not in rescaled_fonts:
    #         f = w.font()
    #         rescaled_fonts.append(f)
    #         f.setPointSize( int( sf * f.pointSize() ) )
    #         w.setFont(f)
    #



def get_screen_dimensions(app):
    """ get total screen size (including all monitors) in pixels """
    return np.sum([ [s.size().width(),s.size().height()] for s in app.screens()],axis=0)


def parse_dashboard_position(pos):
    """ parse the 'dashboard_position' option to get x,y coordinates
        for the GUI dashboard window. 'dashboard_position' may be either:
            (a) a string like 'top right' or 'lower left'
                (technically: [top | upper | bottom | lower] + [left | right] )
            (b) two floating-point numbers, like '0.25 0.75' or '(0.5,0.25)' or '0.75+0.0'
    """
    try:
        x0 = 0.0 if srch(r'left',pos,I) else 0.5 if srch(r'right',pos,I) else None
        y0 = 0.0 if srch(r'top|upper',pos,I) else 0.5 if srch(r'bottom|lower',pos,I) else None
        if x0 is None or y0 is None:
            x0, y0 = [ float(s) for s in re.sub(r'[^0-9.]',' ',pos).split()[0:2] ]
    except:
        x0, y0 = 0.0, 0.0
    log('dashboard_position {} --> x0,y0=({},{})'.format(pos,x0,y0))
    return x0, y0


def run_dashboard(sock):
    """ Create and launch GUI dashboard window, then enter its event loop.

    Args:
        sock: incoming data socket monitored for updates to
              dashboard elements.

    Returns:
        exit status returned by QApplication upon window shutdown.
    """
    opts = ['size', 'position', 'on_top', 'font_family', 'font_scale']
    dx, pos, on_top, ffmly, fscale = [adj_opt('dashboard_' + s) for s in opts]
    if dx==0.0:
        log('dashboard_size option set to 0; skipping GUI dashboard')
        return 0
    app       = QApplication(sys.argv)
    db_widget = QWidget()
    dashboard = TunableDashboard()
    sx, sy    = get_screen_dimensions(app)
    dashboard.setup(db_widget, sock, width=int(sx*dx), ffmly=ffmly, fscale=fscale)
    x0, y0 = parse_dashboard_position(pos)
    db_widget.move( int(sx*x0), int(sy*y0) )
    db_widget.setFixedSize( db_widget.width(), db_widget.height() )
    db_widget.setWindowFlags( Qt.Window | (Qt.WindowStaysOnTopHint if on_top else 0) )
    msg = 'created dashboard: sx,sy,dx,x0,y0,on_top,geometry={},{},{},{},{},{},{}'
    log(msg.format(sx,sy,dx,x0,y0,on_top,db_widget.geometry()))
    db_widget.show()
    return app.exec_()


def dashboard_server(single_session=False):
    """Launch GUI dashboard server.

    This routine listens for incoming TCP connections to the
    address specified by the 'dashboard_{host,port}' options
    in the meep_adjoint configuration. The default address is
    localhost:37673 (in honor of the impedance of free space). Upon
    receiving a connection, we launch the GUI dashboard window
    and read update commands from the client until we receive
    a 'terminate' command or the connection is lost, whereupon
    we close the window.

    If single_session==False, we serve only a single dashboard
    session, exiting when it is complete. This is intended
    for the case in which the server process is forked as a
    subprocess by a meep_adjoint client.
    Otherwise (single_session==False, the default), we enter
    an infinite loop like a typical server, re-awaiting
    connections from new clients after the completion of each session.
    """
    init_log(filename='dashboard.log', usecs=True)
    if 'PyQt5.QtCore' not in sys.modules:
        warn('failed to load PyQt5 modules; skipping GUI dashboard')
        return
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as listener_socket:
        try:
            host, port = [adj_opt('dashboard_' + s) for s in ['host','port']]
            listener_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            listener_socket.bind( (host, port) )
            listener_socket.listen(1)
        except:
            return get_exception_info(msg='db_server bind/listen failed',warning=True)

        while True:
            log('db_server {} listening at {}:{}'.format(os.getpid(),host,port))
            handler_socket, client_addr = listener_socket.accept()
            log('db_server got incoming connection')
            status = run_dashboard(handler_socket)
            log('run_dashboard returned with status={}'.format(status))
            if single_session:
                sys.exit(status)


if __name__ == '__main__':
    dashboard_server(single_session=('--single_session' in sys.argv))
