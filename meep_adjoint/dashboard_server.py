""" Control interface wrappers around the basic dashboard GUI.
"""
import os
from os import environ as env
import sys
import time
import select
import socket
import subprocess
import asyncio
import numpy as np

if __package__ == 'meep_adjoint':
    from . import init_log, log, warn, get_exception_info
else:
    from util import init_log, log, warn, get_exception_info

######################################################################
# attempt to import PyQt5, postponing failure messages until later
######################################################################
try:
    from PyQt5 import QtCore, QtGui, QtWidgets
    from PyQt5.QtCore import Qt, QSocketNotifier, QTimer
    from PyQt5.QtWidgets import (QApplication, QWidget, QLCDNumber,
                                 QLabel, QProgressBar)

    """dashboard_gui.py is a module autogenerated by QT Designer from
       the design file dashboard_gui.ui. It implements a base class named
       Ui_BaseDashboard, which we subclass below to define our TunableDashboard
       class.
    """
    from dashboard_gui import Ui_BaseDashboard

except ImportError:
    pass

######################################################################
######################################################################
######################################################################
"""list of updatable display elements in the dashboard GUI"""
db_host, db_port = 'localhost', 16761
BUFSIZE = 4096
DASHBOARD_ELEMENTS = ['cpus', 'cpu_usage', 'ms_per_timestep',
                      'run', 'stage', 'progress',
                      'iteration', 'sub_iteration', 'alpha',
                      'start', 'current', 'best']

######################################################################
######################################################################
######################################################################
class TunableDashboard(Ui_BaseDashboard):
    """GUI dashboard console for meep_adjoint."""

    def setup(self, db_widget, sock, width=960):
        """Initialize GUI dashboard widget """

        self.db_widget, self.sock = db_widget, sock
        self.setupUi(db_widget, width=width)

        """ arrange for read_input to be called whenever data is available on the socket"""
        self.notifier = QSocketNotifier( (sock or sys.stdin).fileno(), QSocketNotifier.Read, db_widget)
        self.notifier.setEnabled(True)
        self.notifier.activated.connect(self.read_input)


    def read_input(self, fd):
        """ Read input lines from the file descriptor and update dashboard elements. Each input
            line should begin with the name of a dashboard element, with the remainder of the line
            being the updated content. The only exception is the input line 'terminate', upon which we exit.
            Non-compliant input lines are ignored with a warning message.
            Examples:
                cpus 8
                cpu_usage 34.5
                run adjoint
                iteration 10
                progress 13
                progress range 7 39
        """
        try:
            #status = fd in select.select([fd],[],[],0)[0]
            #log('read_input called with fd={} (self={}), select={}...'.format(fd, (self.sock or sys.stdin).fileno(), status))
            #received = str( self.sock.recv(BUFSIZE), 'utf-8' ) if self.sock else sys.stdin.readline()
            #log('...len(received)={} and select={}'.format(len(received), fd in select.select([fd],[],[],0)[0]))
            received = str( self.sock.recv(BUFSIZE), 'utf-8' )
            err = 'terminate' if received.lower().startswith('terminate') else 'EOF' if len(received)==0 else None
        except:
            err, msg = 'exception', get_exception_info(warning=True)

        if err:
            log('{} on {}, closing dashboard'.format(err, 'socket' if self.sock else 'stdin'))
            if self.sock:
                self.sock.close()
            self.notifier.setEnabled(False)
            self.db_widget.close()
            return

        for (ln, n) in [ (l,l.find(' ')) for l in received.split('\n') if l ]:
            key, val = (ln.lower(), '') if n<0 else (ln[:n].lower(), ln[n+1:])
            if key in DASHBOARD_ELEMENTS:
                self.update_item(key, val)
            elif key=='title':
                self.db_widget.setWindowTitle(val)
            elif key=='width':
                self.rescale( width_fraction = float(val) )
            else:
                log('ignoring unrecognized dashboard update: ' + ln)


    def update_item(self, item, value):
        """ Set GUI dashboard element 'item' to value 'value' """
        msg, w = None, self.get_widget_by_name(item)
        if isinstance(w, QLCDNumber):
            w.display(value)
        elif isinstance(w, QLabel):
            w.setText(value)
        elif isinstance(w, QProgressBar):
            tok = value.split()
            if len(tok) == 1 and tok[0].isdigit():
                w.setProperty('value', int(tok[0]) )
            elif len(tok) == 3 and tok[0] == 'range' and tok[1].isdigit() and tok[2].isdigit():
                w.setRange(int(tok[1]), int(tok[2]))
                w.setProperty('value', int(tok[1]))
            else:
                msg = 'failed to process progress-bar update: {} {}'.format(item, value)
        else:
            msg = 'failed to process update for unknown dashboard element {}={}'.format(item, value)

        if msg:
            log('warning: {}'.format(msg))
        else:
            self.db_widget.update()


    def get_widget_by_name(self, name):
        if name.lower() == 'progress':
            return self.progress
        for w in self.db_widget.children():
            if w.objectName().strip(' :').lower() == name.lower():
                return w
        return None

    # Implementation of auto-resizing. Currently disabled.
    #
    # def rescale(self, scale_factor=None, rel_width = None )
    #     if scale_factor is None:
    #         new_width, old_width = rel_width * SX, self.db_widget.width()
    #         scale_factor = (1.0*new_width) / (1.0*old_width)
    #     self.scale_widget(self.db_widget, scale_factor, [])
    #     self.db_widget.update()
    #
    #
    # def scale_widget(self, w, sf, rescaled_fonts):
    #     if hasattr(w,'children'):
    #         for child in w.children():
    #             self.scale_widget(child, sf)
    #     if hasattr(w,'size'):
    #         w.resize( sf * w.size() )
    #         if w!=self.db_widget:
    #             w.move( int(sf*w.x()), int(sf*(w.y())) )
    #     if hasattr(w,'font') and w.font() not in rescaled_fonts:
    #         f = w.font()
    #         rescaled_fonts.append(f)
    #         f.setPointSize( int( sf * f.pointSize() ) )
    #         w.setFont(f)
    #



def get_screen_dimensions(app):
    """ get total screen size (including all monitors) in pixels """
    return np.sum([ [s.size().width(),s.size().height()] for s in app.screens()],axis=0)

def create_dashboard(sock=None):
    """ Initialize GUI dashboard window, but do not yet display it
        or enter its event loop.

    Args:
        sock: socket returned by accept(), to be monitored for input
              requesting updates to dashboard items.
              If sock==None, we instead monitor sys.stdin.

    Return value:
        3-tuple (app, db_widget, dashboard)
    """
    app       = QApplication(sys.argv)
    db_widget = QWidget()
    dashboard = TunableDashboard()
    sx, sy    = get_screen_dimensions(app)
    name, dx, x0, y0, on_top = 'hello', 0.5, 0.5, 0.0, True
    dashboard.setup(db_widget, sock, width=int(sx*dx))
    db_widget.move( int(sx*x0), int(sy*y0) )
    db_widget.setFixedSize( db_widget.width(), db_widget.height() )
    db_widget.setWindowTitle('meep_adjoint dashboard' + (': ' + name) if name else '' )
    db_widget.setWindowFlags( Qt.Window | (Qt.WindowStaysOnTopHint if on_top else 0) )
    return app, db_widget, dashboard


def run_dashboard(sock=None):
    """Create and run GUI dashboard window."""
    app, db_widget, dashboard = create_dashboard(sock=sock)
    db_widget.show()
    return app.exec_()


def dashboard_server(persist=False):
    init_log(filename='dashboard.log', usecs=True)
    if 'PyQt5.QtCore' not in sys.modules:
        warn('failed to load PyQt5 modules; skipping GUI dashboard')
        return
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as listener_socket:
        try:
            listener_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            listener_socket.bind( (db_host, db_port) )
            listener_socket.listen(1)
        except:
            msg=get_exception_info(exc_info=None,msg='db_server bind/listen failed')
            warn(msg.split('\n')[0])
            return

        while True:
            log('db_server {} listening at {}:{}'.format(os.getpid(),db_host,db_port))
            handler_socket, client_addr = listener_socket.accept()
            handler_socket.setblocking(False)
            log('db_server got incoming connection')
            status = run_dashboard(handler_socket)
            log('run_dashboard returned with status={}'.format(status))
            if not persist:
                return


if __name__ == '__main__':
    dashboard_server(persist=('--persist' in sys.argv[1:]))
