""" Filter meep stdout to extract relevant information and
    (optionally) report it and other data to a GUI or
    terminal-based dashboard console
"""
import os
from os import environ as env
import sys
import time
from datetime import datetime as dt2
import multiprocessing
from warnings import warn
from collections import namedtuple

import meep as mp

from . import get_adjoint_option as adj_opt
from . import log

from .adjoint_options import set_adjoint_options

######################################################################
# attempt to import PyQt5, postponing failure messages until later
######################################################################
try:
    from PyQt5 import QtCore, QtGui, QtWidgets
    from PyQt5.QtCore import QSocketNotifier, QTimer
    from PyQt5.QtWidgets import (QApplication, QWidget, QLCDNumber,
                                 QLabel, QProgressBar)
    """qt_dashboard.py is a module generated by QT Designer (based on
       the design file qt_dashboard.ui) that defines a class named
       Ui_Form implementing the basic GUI, which we subclass below
    """
    from .qt_dashboard import Ui_Form

except ImportError:
    pass


"""list of updatable display elements in the dashboard GUI"""
DASHBOARD_ELEMENTS = ['cpus', 'cpu_usage', 'ms_per_timestep',
                      'run', 'stage', 'progress',
                      'iteration', 'sub_iteration', 'alpha',
                      'start', 'current', 'best']

class Dashboard(Ui_Form):
    """GUI dashboard console for meep_adjoint.
       On instantiation, this class displays the meep_adjoint GUI dashboard,
       then reads lines from the pipe to update dashboard data fields.
    """
    def setup(self, Form, pipe, width=960):
        """Initialize dashboard widget:
            (a) Call the parent class' initialization routine to set up the widget
            (b) Register a callback for events indicating incoming data to read
                from the pipe
            (c) Set the number of CPUs (which is fixed) and create a timer and
                callback routine to update CPU usage.
           Arguments:
               pipe: the child end of the Pipe() created by the parent
                     process, from which we read updates to dashboard data fields
               width: the width of the created window in pixels.
           Returns: none
        """
        self.Form, self.pipe = Form, pipe
        self.setupUi(Form, width=width)

        """ arrange for read_input to be called whenever data is available on the pipe"""
        notifier = QSocketNotifier(pipe.fileno(), QSocketNotifier.Read, Form)
        notifier.setEnabled(True)
        notifier.activated.connect(self.read_input)

        """ fill in dashboard CPU count field """
        self.update_item('cpus',int(mp.count_processors()))

        """ setup regular updates of cpu_usage indicator iff psutil is present."""
        try:
            import psutil
            self.proc = psutil.Process(os.getpid()).parent()
            self.proc.cpu_percent()
            self.cpu_usage_timer = QTimer(self.Form)
            self.cpu_usage_timer.timeout.connect(self.update_cpu_usage)
            self.cpu_usage_timer.start(int(adj_opt('dashboard_cpu_interval')))
        except:
            self.update_item('cpu_usage',0.0)
            self.proc, err = None, sys.exc_info()[0]
            warn('failed to initialize psutil ({}); CPU usage not available'.format(err))


    def update_cpu_usage(self):
        self.update_item('cpu_usage',self.proc.cpu_percent())


    def read_input(self, fd):
        """ Read lines of input from the pipe and update elements of the dashboard
            accordingly. Each input line should begin with the name of a dashboard
            element, with the remainder of the line being the updated content.
            The only exception is the input line 'terminate', upon which we exit.
            Input lines that do not match this pattern are ignored.
            Examples:
                cpus 8
                cpu_usage 34.5
                iteration 10
                sub_iteration 3
                progress 13
        """
        input = ''
        while self.pipe.poll():
            input += str( self.pipe.recv(), 'utf-8' )
        for (ln, n) in [ (l,l.find(' ')) for l in input.split('\n') if l ]:
            key, val = (ln.lower(), '') if n<0 else (ln[:n].lower(), ln[n+1:])
            if key == 'terminate':
                self.Form.close()
            elif key in DASHBOARD_ELEMENTS:
                self.update_item(key, val)
            else:
                warn('ignoring unrecognized dashboard update: ' + ln)


    def update_item(self, item, value):
        """ Set the value of the GUI dashboard element named 'item'
        """
        w = self.get_widget_by_name(item)
        if w is None:
            return
        if isinstance(w,QLCDNumber):
            w.display(value)
        elif isinstance(w,QLabel):
            w.setText(value)
        elif isinstance(w,QProgressBar):
            w.setProperty("value", int(value) )
        self.Form.update()


    def get_widget_by_name(self, name):
        if name.lower() == 'progress':
            return self.progress
        for w in self.Form.children():
            if w.objectName().strip(' :').lower() == name.lower():
                return w
        return None



def dashboard_gui(pipe, name=None, width=None, x0=None, y0=None, launch=True):
    """ Initialize GUI dashboard window. This routine is typically
        executed by a child process spawned from the main process.
        Parameters:
            pipe: pipe from parent process, which we monitor for data updates
            name: name of optimization problem
            width, x0, y0: width and coordinates of upper-left corner,
                           as a fraction of total screen size.
                           example: (width, x0, y0) = (0.5, 0.5, 0.0)
                                    gives a dashboard of half the total screen
                                    width position in the upper-right screen corner.
            launch: If True, display the window and enter its event loop, from which
                    we never return. This is what we typically want to do. If False,
                    return (app,Form,dashboard) without showing the window or invoking
                    its event loop. This is useful for interactive debugging.
    """
    name  = adj_opt('filebase') if name is None else name
    width, x0, y0 = [ adj_opt('dashboard_' + s) for s in ['width', 'x0', 'y0'] ]
    set_adjoint_options({'logfile':'/tmp/dashboard_gui.log'})
    app, Form, dashboard = QApplication(sys.argv), QWidget(), Dashboard()
    log('howdage 1')
    screen_size = app.primaryScreen().size()
    screen_width, screen_height = screen_size.width(), screen_size.height()
    log('howdage 2 {}, {}'.format(screen_width,screen_height))
    dashboard.setup(Form, pipe, width=int(width*screen_width) )
    log('howdage 3')
    if name:
        Form.setWindowTitle('meep_adjoint dashboard for {}'.format(name))
    log('howdage 4')
    g = Form.geometry()
    log('howdage 5')
    Form.setGeometry(int(x0*screen_width), int(y0*screen_height), g.width(), g.height())
    log('howdage 6')
    if launch:
        Form.show()
        log('howdage 7')
        sys.exit(app.exec_())
    return app, Form, dashboard

######################################################################
######################################################################
######################################################################
DashboardController = namedtuple('DashboardController',['pipe','process'])

_mpadj_dashboard = None

def launch_dashboard():
    """Fork a child process to run the GUI dashboard and return
       a DashboardController storing (pipe, process), where process
       is the multiprocessing Process for the child and pipe is a
       channel via which we send it update commands.
    """
    if 'PyQt5.QtCore' not in sys.modules:
        msg = 'failed to load PyQt5 modules'
    elif adj_opt('dashboard_width')==0:
        msg = 'dashboard_width set to 0'
    else:
        global _mpadj_dashboard
        if _mpadj_dashboard is not None:
            return _mpadj_dashboard
        try:
            pipe, child_end = multiprocessing.Pipe()
            process = multiprocessing.Process(target=dashboard_gui, args=(child_end,))
            process.start()
            _mpadj_dashboard = DashboardController(pipe, process)
            return _mpadj_dashboard
        except:
            msg = 'error launching child process'
    warn(msg + '; skipping GUI dashboard')


def close_dashboard(controller=None):
    """send the 'terminate' command, wait 5 seconds for dashboard to
       close properly, then force-kill it if necessary
    """
    global _mpadj_dashboard
    controller = controller or _mpadj_dashboard
    if controller is None:
        return
    process = controller.process
    if process and process.is_alive():
        update_dashboard(controller, 'terminate')
        process.join(5)
        if process.is_alive():
            process.kill()
    if controller == _mpadj_dashboard:
        _mpadj_dashboard = None


def update_dashboard(item, val='', controller=None):
    """issue command to GUI window to update value of element 'item' to 'val' """
    global _mpadj_dashboard
    controller = controller or _mpadj_dashboard
    if controller is None:
        return
    if controller.pipe:
            line = item + (' ' + val if val else '') + '\n'
            controller.pipe.send( bytes(line, 'utf-8') )


######################################################################
######################################################################
######################################################################
class ConsoleManager(object):

    def __init__(self):
        """ Q: For context managers in general, how does one decide
               which initialization/startup code goes in __init__ vs.
               which goes in _enter__?
        """
        pass


    def __enter__(self):
        if not mp.am_master():
            return
        self.stdout, sys.stdout = sys.stdout, self
        self.teefile = open('/tmp/stdout.tee','w')
        return self


    def __exit__(self, type, value, traceback):
        if not mp.am_master():
            return
        sys.stdout = self.stdout
        if self.teefile:
            self.teefile.close()


    def write(self, text):
        if self.teefile:
            self.teefile.write(text)
        for line in [l for l in text.split('\n') if l]:
            if line.split()[0].lower() in DASHBOARD_ELEMENTS:
                update_dashboard(line)
            else:
                self.stdout.write(text)


    def flush(self):
        pass
